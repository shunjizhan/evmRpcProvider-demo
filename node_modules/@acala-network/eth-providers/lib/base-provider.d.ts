import { AcalaEvmTX } from '@acala-network/eth-transactions';
import type { EvmAccountInfo, EvmContractInfo } from '@acala-network/types/interfaces';
import { Block, BlockWithTransactions, EventType, FeeData, Filter, FilterByBlockHash, Listener, Log, Provider as AbstractProvider, Provider, TransactionReceipt, TransactionRequest, TransactionResponse } from '@ethersproject/abstract-provider';
import { Network } from '@ethersproject/networks';
import { Deferrable } from '@ethersproject/properties';
import { Formatter } from '@ethersproject/providers';
import { Transaction } from '@ethersproject/transactions';
import { ApiPromise } from '@polkadot/api';
import '@polkadot/api-augment';
import { VersionedRegistry } from '@polkadot/api/base/types';
import { SubmittableExtrinsic } from '@polkadot/api/types';
import type { GenericExtrinsic, Option } from '@polkadot/types';
import type { EventRecord, Header } from '@polkadot/types/interfaces';
import { Storage } from '@polkadot/types/metadata/decorate/types';
import { BigNumber, BigNumberish } from 'ethers';
import { AccessListish } from 'ethers/lib/utils';
import LRUCache from 'lru-cache';
import { HealthResult } from './utils';
import { BlockCache, CacheInspect } from './utils/BlockCache';
import { TransactionReceipt as TransactionReceiptGQL, _Metadata } from './utils/gqlTypes';
import { SubqlProvider } from './utils/subqlProvider';
export declare type BlockTag = 'earliest' | 'latest' | 'pending' | string | number;
export declare type Signature = 'Ethereum' | 'AcalaEip712' | 'Substrate';
export interface BlockData {
    hash: `0x${string}`;
    parentHash: `0x${string}`;
    number: number;
    stateRoot: `0x${string}`;
    transactionsRoot: `0x${string}`;
    timestamp: number;
    nonce: `0x${string}`;
    mixHash: `0x${string}`;
    difficulty: number;
    totalDifficulty: number;
    gasLimit: BigNumber;
    gasUsed: BigNumber;
    miner: string;
    extraData: `0x${string}`;
    sha3Uncles: `0x${string}`;
    receiptsRoot: `0x${string}`;
    logsBloom: `0x${string}`;
    size: number;
    uncles: string[];
    transactions: `0x${string}`[];
}
export interface FullBlockData extends Omit<BlockData, 'transactions'> {
    transactions: TX[];
}
export interface CallRequest {
    from?: string;
    to?: string;
    gasLimit?: BigNumberish;
    storageLimit?: BigNumberish;
    value?: BigNumberish;
    data?: string;
    accessList?: AccessListish;
}
export interface partialTX {
    from: string;
    to: string | null;
    blockHash: string | null;
    blockNumber: number | null;
    transactionIndex: number | null;
}
export interface TX extends partialTX {
    hash: string;
    nonce: number;
    value: BigNumberish;
    gasPrice: BigNumberish;
    gas: BigNumberish;
    input: string;
    v: string;
    r: string;
    s: string;
}
export interface TXReceipt extends partialTX {
    contractAddress: string | null;
    root?: string;
    gasUsed: BigNumber;
    logsBloom: string;
    transactionHash: string;
    logs: Array<Log>;
    confirmations: number;
    cumulativeGasUsed: BigNumber;
    effectiveGasPrice: BigNumber;
    type: number;
    status?: number;
}
export interface GasConsts {
    storageDepositPerByte: bigint;
    txFeePerGas: bigint;
}
export interface EventListener {
    id: string;
    cb: (data: any) => void;
    filter?: any;
}
export interface EventListeners {
    [name: string]: EventListener[];
}
export interface EventData {
    [index: string]: {
        weight: number;
        class: string;
        paysFee: string;
    };
}
export interface BaseProviderOptions {
    safeMode?: boolean;
    localMode?: boolean;
    verbose?: boolean;
    subqlUrl?: string;
    maxBlockCacheSize?: number;
    storageCacheSize?: number;
    healthCheckBlockDistance?: number;
}
export declare const defaultOpts: BaseProviderOptions;
export declare type NewBlockListener = (header: Header) => any;
export declare type BlockTagish = BlockTag | Promise<BlockTag> | undefined;
export declare abstract class BaseProvider extends AbstractProvider {
    readonly _api?: ApiPromise;
    readonly formatter: Formatter;
    readonly _listeners: EventListeners;
    readonly safeMode: boolean;
    readonly localMode: boolean;
    readonly verbose: boolean;
    readonly subql?: SubqlProvider;
    readonly maxBlockCacheSize: number;
    readonly storages: WeakMap<VersionedRegistry<'promise'>, Storage>;
    readonly _storageCache: LRUCache<string, Uint8Array | null>;
    readonly _healthCheckBlockDistance: number;
    _newBlockListeners: NewBlockListener[];
    _network?: Promise<Network>;
    _cache?: BlockCache;
    latestFinalizedBlockHash: string | undefined;
    latestFinalizedBlockNumber: number | undefined;
    runtimeVersion: number | undefined;
    constructor({ safeMode, localMode, verbose, subqlUrl, maxBlockCacheSize, storageCacheSize, healthCheckBlockDistance }?: BaseProviderOptions);
    startSubscription: () => Promise<any>;
    setApi: (api: ApiPromise) => void;
    queryStorage: <T = any>(module: `${string}.${string}`, args: any[], _blockTag?: BlockTag | Promise<BlockTag> | undefined) => Promise<T>;
    get api(): ApiPromise;
    get genesisHash(): string;
    get isConnected(): boolean;
    get chainDecimal(): number;
    get isSafeMode(): boolean;
    isReady: () => Promise<Network>;
    disconnect: () => Promise<void>;
    getNetwork: () => Promise<Network>;
    netVersion: () => Promise<string>;
    chainId: () => Promise<number>;
    getBlockNumber: () => Promise<number>;
    _getBlock: (_blockTag: BlockTag | Promise<BlockTag>) => Promise<BlockData>;
    _getFullBlock: (blockTag: BlockTag | Promise<BlockTag>) => Promise<FullBlockData>;
    getBlockData: (blockTag: BlockTag | Promise<BlockTag>, full?: boolean | undefined) => Promise<BlockData | FullBlockData>;
    getBlock: (blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>) => Promise<Block>;
    getBlockWithTransactions: (blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>) => Promise<BlockWithTransactions>;
    getBalance: (addressOrName: string | Promise<string>, _blockTag?: BlockTag | Promise<BlockTag> | undefined) => Promise<BigNumber>;
    getTransactionCount: (addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag> | undefined) => Promise<number>;
    getEvmTransactionCount: (addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag> | undefined) => Promise<number>;
    getSubstrateNonce: (addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag> | undefined) => Promise<number>;
    getCode: (addressOrName: string | Promise<string>, _blockTag?: BlockTag | Promise<BlockTag> | undefined) => Promise<string>;
    call: (transaction: Deferrable<TransactionRequest>, _blockTag?: BlockTag | Promise<BlockTag> | undefined) => Promise<string>;
    getStorageAt: (addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, _blockTag?: BlockTag | Promise<BlockTag> | undefined) => Promise<string>;
    resolveName: (name: string | Promise<string>) => Promise<string>;
    getGasPrice: () => Promise<BigNumber>;
    getFeeData: () => Promise<FeeData>;
    _getGasConsts: () => GasConsts;
    /**
     * Estimate gas for a transaction.
     * @param transaction The transaction to estimate the gas of
     * @returns The estimated gas used by this transaction
     */
    estimateGas: (transaction: Deferrable<TransactionRequest>) => Promise<BigNumber>;
    /**
     * Get the gas for eth transactions
     * @returns The gas used by eth transaction
     */
    getEthResources: (transaction: Deferrable<TransactionRequest>, { gasLimit, storageLimit, validUntil }?: {
        gasLimit?: BigNumberish | undefined;
        storageLimit?: BigNumberish | undefined;
        validUntil?: BigNumberish | undefined;
    }) => Promise<{
        gasPrice: BigNumber;
        gasLimit: BigNumber;
    }>;
    /**
     * helper to get ETH gas when don't know the whole transaction
     * default to return big enough gas for contract deployment
     * @returns The gas used by eth transaction
     */
    _getEthGas: ({ gasLimit, storageLimit, validUntil: _validUntil }?: {
        gasLimit?: BigNumberish | undefined;
        storageLimit?: BigNumberish | undefined;
        validUntil?: BigNumberish | undefined;
    }) => Promise<{
        gasPrice: BigNumber;
        gasLimit: BigNumber;
    }>;
    /**
     * Validate substrate transaction parameters
     */
    validSubstrateResources: ({ gasLimit, gasPrice }: {
        gasLimit: BigNumberish;
        gasPrice: BigNumberish;
    }) => {
        gasLimit: BigNumber;
        storageLimit: BigNumber;
        validUntil: BigNumber;
    };
    /**
     * Estimate resources for a transaction.
     * @param transaction The transaction to estimate the resources of
     * @returns The estimated resources used by this transaction
     */
    estimateResources: (transaction: Deferrable<TransactionRequest>) => Promise<{
        gas: BigNumber;
        storage: BigNumber;
        weightFee: BigNumber;
    }>;
    getSubstrateAddress: (addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag> | undefined) => Promise<string>;
    getEvmAddress: (substrateAddress: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag> | undefined) => Promise<string>;
    queryAccountInfo: (addressOrName: string | Promise<string>, _blockTag?: BlockTag | Promise<BlockTag> | undefined) => Promise<Option<EvmAccountInfo>>;
    queryContractInfo: (addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag> | undefined) => Promise<Option<EvmContractInfo>>;
    _getSubstrateGasParams: (ethTx: AcalaEvmTX) => {
        gasLimit: bigint;
        storageLimit: bigint;
        validUntil: bigint;
        tip: bigint;
        accessList?: [string, string[]][] | undefined;
    };
    prepareTransaction: (rawTx: string) => Promise<{
        extrinsic: SubmittableExtrinsic<'promise'>;
        transaction: AcalaEvmTX;
    }>;
    sendRawTransaction: (rawTx: string) => Promise<string>;
    sendTransaction: (signedTransaction: string | Promise<string>) => Promise<TransactionResponse>;
    _wrapTransaction: (tx: AcalaEvmTX, hash: string, startBlock: number, startBlockHash: string) => Promise<TransactionResponse>;
    _getBlockHash: (_blockTag?: BlockTag | Promise<BlockTag> | undefined) => Promise<string>;
    _isBlockFinalized: (blockTag: BlockTag) => Promise<boolean>;
    _isTransactionFinalized: (txHash: string) => Promise<boolean>;
    _ensureSafeModeBlockTagFinalization: (_blockTag: BlockTagish) => Promise<BlockTagish>;
    _getBlockHeader: (blockTag?: BlockTag | Promise<BlockTag> | undefined) => Promise<Header>;
    _getAddress: (addressOrName: string | Promise<string>) => Promise<string>;
    _getTransactionRequest: (transaction: Deferrable<TransactionRequest>) => Promise<Partial<Transaction>>;
    _getTxHashesAtBlock: (blockHash: string) => Promise<string[]>;
    _parseTxAtBlock: (blockHash: string, targetTx: string | number) => Promise<{
        extrinsic: GenericExtrinsic;
        extrinsicEvents: EventRecord[];
        transactionHash: string;
        transactionIndex: number;
        isExtrinsicFailed: boolean;
    }>;
    getTransactionReceiptAtBlock: (hashOrNumber: number | string | Promise<string>, _blockTag: BlockTag | Promise<BlockTag>) => Promise<TransactionReceipt>;
    static isProvider(value: any): value is Provider;
    _getTxReceiptFromCache: (txHash: string) => Promise<TransactionReceipt | null>;
    _getPendingTX: (txHash: string) => Promise<TX | null>;
    _getMinedTXReceipt: (txHash: string) => Promise<TransactionReceipt | TransactionReceiptGQL | null>;
    getTransaction: (txHash: string) => Promise<TransactionResponse>;
    getTransactionByHash: (txHash: string) => Promise<TX | null>;
    getTransactionReceipt: (txHash: string) => Promise<TransactionReceipt>;
    getTXReceiptByHash: (txHash: string) => Promise<TXReceipt | null>;
    _getBlockNumberFromTag: (blockTag: BlockTag) => Promise<number>;
    getLogs: (rawFilter: Filter & FilterByBlockHash) => Promise<Log[]>;
    getIndexerMetadata: () => Promise<_Metadata | undefined>;
    getCachInfo: () => CacheInspect | undefined;
    _timeEthCalls: () => Promise<{
        gasPriceTime: number;
        estimateGasTime: number;
        getBlockTime: number;
        getFullBlockTime: number;
    }>;
    healthCheck: () => Promise<HealthResult>;
    lookupAddress: (address: string | Promise<string>) => Promise<string>;
    waitForTransaction: (transactionHash: string, confirmations?: number | undefined, timeout?: number | undefined) => Promise<TransactionReceipt>;
    addEventListener: (eventName: string, listener: Listener, filter?: any) => string;
    removeEventListener: (id: string) => boolean;
    on: (eventName: EventType, listener: Listener) => Provider;
    once: (eventName: EventType, listener: Listener) => Provider;
    emit: (eventName: EventType, ...args: Array<any>) => boolean;
    listenerCount: (eventName?: EventType | undefined) => number;
    listeners: (eventName?: EventType | undefined) => Array<Listener>;
    off: (eventName: EventType, listener?: Listener | undefined) => Provider;
    removeAllListeners: (eventName?: EventType | undefined) => Provider;
}
//# sourceMappingURL=base-provider.d.ts.map